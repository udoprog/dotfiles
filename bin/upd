#!/usr/bin/env python3
import os
import sys
import subprocess as sp
import time

# 1 day
UPDATE_TIMEOUT = 60 * 60 * 24


def query_yes_no(question, default="yes"):
    valid = {"yes": True, "y": True, "ye": True, "no": False, "n": False}

    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()

        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")


def touch_last_sync(last_sync):
    def inner():
        os.makedirs(os.path.dirname(last_sync), exist_ok=True)
        open(last_sync, 'w')

    return inner


def needs_update(root):
    last_sync = os.path.join(root, 'state', 'last-sync')
    not_found = False

    try:
        st = os.stat(last_sync)
    except FileNotFoundError:
        not_found = True

    if not not_found:
        now = time.time()
        diff = now - st.st_mtime

        if diff < UPDATE_TIMEOUT:
            return (False, lambda: None)

    return True, touch_last_sync(last_sync)


class Git:
    def __init__(self, root):
        self.root = root

    def __git(self, *args):
        full = [b'git']

        for arg in args:
            if isinstance(arg, str):
                full.append(arg.encode('utf-8'))
            else:
                full.append(arg)

        return full

    def __git_run(self, *args):
        full = self.__git(*args)
        p = sp.Popen(full, cwd=self.root)
        p.wait()

        if p.returncode != 0:
            cmd = b' '.join(full).decode('utf-8')
            raise Exception(
                'non-zero exit status: {}: {}'.format(cmd, p.returncode)
            )

    def __git_status(self, *args):
        full = self.__git(*args)
        p = sp.Popen(full, cwd=self.root)
        p.wait()
        return p.returncode

    def __git_out(self, *args):
        full = self.__git(*args)
        p = sp.Popen(full, stdout=sp.PIPE, cwd=self.root)
        (out, _) = p.communicate()

        if p.returncode != 0:
            cmd = b' '.join(full).decode('utf-8')
            raise Exception(
                'non-zero exit status: {}: {}'.format(cmd, p.returncode)
            )

        return out

    def get_head(self):
        return self.__git_out('rev-parse', 'HEAD').strip()

    def merge_base(self, a, b):
        return self.__git_out('merge-base', a, b).strip()

    def needs_update(self):
        self.__git_run('fetch', 'origin', 'master')
        remote_head = self.__git_out('rev-parse', 'FETCH_HEAD').strip()
        head = self.get_head()

        if remote_head != head:
            # check if remote is a base
            return self.merge_base(remote_head, head) != remote_head

        return False

    def is_fresh(self):
        """
        Check if the local repository has not been modified without comitting.
        """
        return self.__git_status('diff-index', '--quiet', 'HEAD') == 0

    def force_update(self):
        self.__git_run('reset', '--hard', 'FETCH_HEAD')

    def update(self):
        self.__git_run('merge', '--ff-only', 'FETCH_HEAD')


if __name__ == '__main__':
    root = os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0])))

    try:
        opts = os.environ['DOTFILES_UPDATE'].split(',')
    except KeyError:
        opts = list()

    force = 'force' in opts
    noninteractive = 'noninteractive' in opts
    # only run on updates
    updates_only = 'updates-only' in opts

    updated = False

    git = Git(root)

    (needs_update, touch) = needs_update(root)

    if needs_update:
        yes = True

        if not noninteractive:
            yes = query_yes_no('Do you want to check for dotfile updates?')

        if yes:
            if git.needs_update():
                print('Updating dotfiles...')

                if force:
                    git.force_update()
                else:
                    git.update()

                updated = True

            touch()

    should_run = not updates_only or updates_only and updated

    if should_run:
        if updates_only:
            print('Updates found, running `upd`...')

        args = ['make', '--no-print-directory', '-C', root]
        args.extend(sys.argv[1:])
        os.execvp('make', args)
